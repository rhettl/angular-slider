// Generated by CoffeeScript 1.6.2
(function () {
    var MODULE_NAME, SLIDER_TAG, BUFFER_TAG, LOGSLIDER_TAG, SCALESLIDER_TAG, angularize, abs, copy, UCFirst, getPointerValue, getLocForPointer, bindHtml, gap, halfWidth, hide, inputEvents, module, offset, offsetLeft, pixelize, qualifiedSliderDirectiveDefinition, qualifiedBufferDirectiveDefinition, qualifiedLogSliderDirectiveDefinition, qualifiedScaleSliderDirectiveDefinition, roundStep, show, sliderDirective, bufferModelDirective, logSliderDirective, scaleSliderDirective, width;

    MODULE_NAME = 'iSlider';

    SLIDER_TAG = 'slider';
    BUFFER_TAG = 'bufferModel';
    LOGSLIDER_TAG = 'logSlider';
    SCALESLIDER_TAG = 'scaleSlider';

    angularize = function (element) {
        return angular.element(element);
    };

    pixelize = function (position) {
        return "" + position + "px";
    };

    hide = function (element) {
        return element.css({
            opacity: 0
        });
    };

    show = function (element) {
        return element.css({
            opacity: 1
        });
    };

    abs = Math.abs;
    copy = angular.copy;
    UCFirst = function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
    };

    offset = function (element, position) {
        return element.css({
            left: position
        });
    };

    halfWidth = function (element) {
        return element[0].offsetWidth / 2;
    };

    offsetLeft = function (element) {
        return element[0].offsetLeft;
    };

    width = function (element) {
        return element[0].offsetWidth;
    };

    gap = function (element1, element2) {
        return offsetLeft(element2) - offsetLeft(element1) - width(element1);
    };

    bindHtml = function (element, html) {
        return element.attr('ng-bind-html-unsafe', html);
    };

    roundStep = function (value, precision, step, floor) {
        var decimals, remainder, roundedValue, steppedValue;

        if (floor == null) {
            floor = 0;
        }
        if (step == null) {
            step = 1 / Math.pow(10, precision);
        }
        remainder = (value - floor) % step;
        steppedValue = remainder > (step / 2) ? value + step - remainder : value - remainder;
        decimals = Math.pow(10, precision);
        roundedValue = steppedValue * decimals / decimals;
        return roundedValue.toFixed(precision);
    };

    inputEvents = {
        mouse: {
            start: 'mousedown',
            move: 'mousemove',
            end: 'mouseup'
        },
        touch: {
            start: 'touchstart',
            move: 'touchmove',
            end: 'touchend'
        }
    };

    getPointerValue = function(value, rangeMarkers, scale){
        if( rangeMarkers && rangeMarkers.length > 0) {
            var mark, _startPercent, _fromVal;

            _startPercent = 0;
            _fromVal = scale[0];

            for (var i = 0; i <= rangeMarkers.length; i++) {
                if (rangeMarkers[i])
                    mark = rangeMarkers[i].split("/");
                else
                    mark = [100, scale[1]];

                mark[0] = new Number(mark[0]); mark[1] = new Number(mark[1]);

                if (value >= _startPercent && value <= mark[0]) {
                    return (value - _startPercent) / (mark[0] - _startPercent) * (mark[1] - _fromVal) + _fromVal;
                }

                _startPercent = mark[0]; _fromVal = mark[1];
            }

        } else {
            return (value / 100) * (scale[1] - scale[0]) + scale[0];
        }
    };
    getLocForPointer = function (value, rangeMarkers, scale){
        if( rangeMarkers && rangeMarkers.length > 0) {
            var mark, _startPercent, _fromVal;
            _startPercent = 0;
            _fromVal = scale[0];

            for (var i = 0; i <= rangeMarkers.length; i++) {
                if (rangeMarkers[i])
                    mark = rangeMarkers[i].split("/");
                else
                    mark = [100, scale[1]];

                mark[0] = new Number(mark[0]); mark[1] = new Number(mark[1]);

                if (value >= _fromVal && value <= mark[1]) {
                    return (((value - _fromVal) * (mark[0] - _startPercent)) / (mark[1] - _fromVal)) + _startPercent;
                }

                _startPercent = mark[0]; _fromVal = mark[1];
            }

        } else {
            return ((value - scale[0]) / (scale[1] - scale[0])) * 100;
        }
    };

    sliderDirective = function ($timeout) {
        return {
            restrict: 'EA',
            scope: {
                floor: '@',
                ceiling: '@',
                step: '@',
                precision: '@',
                ngModel: '=?',
                ngModelLow: '=?',
                ngModelHigh: '=?',
                translate: '&'
            },
            template: '<span class="bar"></span>' +
                '<span class="bar selection"></span>' +
                '<span class="pointer"></span>' +
                '<span class="pointer"></span>' +
                '<span class="bubble selection"></span>' +
                '<span ng-bind-html-unsafe="translate({value: floor})" class="bubble limit"></span>' +
                '<span ng-bind-html-unsafe="translate({value: ceiling})" class="bubble limit"></span>' +
                '<span class="bubble"></span>' +
                '<span class="bubble"></span>' +
                '<span class="bubble"></span>',
            compile: function (element, attributes) {
                var ceilBub, cmbBub, e, flrBub, fullBar, highBub, lowBub, maxPtr, minPtr, range, refHigh, refLow, selBar, selBub, watchables, _i, _len, _ref, _ref1;

                if (attributes.translate) {
                    attributes.$set('translate', "" + attributes.translate + "(value)");
                }
                range = (attributes.ngModel == null) && ((attributes.ngModelLow != null) && (attributes.ngModelHigh != null));
                _ref = (function () {
                    var _i, _len, _ref, _results;

                    _ref = element.children();
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        e = _ref[_i];
                        _results.push(angularize(e));
                    }
                    return _results;
                })(), fullBar = _ref[0], selBar = _ref[1], minPtr = _ref[2], maxPtr = _ref[3], selBub = _ref[4], flrBub = _ref[5], ceilBub = _ref[6], lowBub = _ref[7], highBub = _ref[8], cmbBub = _ref[9];
                refLow = range ? 'ngModelLow' : 'ngModel';
                refHigh = 'ngModelHigh';
                bindHtml(selBub, "'Range: ' + translate({value: diff})");
                bindHtml(lowBub, "translate({value: " + refLow + "})");
                bindHtml(highBub, "translate({value: " + refHigh + "})");
                bindHtml(cmbBub, "translate({value: " + refLow + "}) + ' - ' + translate({value: " + refHigh + "})");
                if (!range) {
                    _ref1 = [selBar, maxPtr, selBub, highBub, cmbBub];
                    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                        element = _ref1[_i];
                        element.remove();
                    }
                }
                watchables = [refLow, 'floor', 'ceiling'];
                if (range) {
                    watchables.push(refHigh);
                }
                return {
                    post: function (scope, element, attributes) {
                        var barWidth, boundToInputs, dimensions, maxOffset, maxValue, minOffset, minValue, ngDocument, offsetRange, pointerHalfWidth, updateDOM, valueRange, w, _j, _len1, rangeMarkers;

                        boundToInputs = false;
                        ngDocument = angularize(document);
                        if (!attributes.translate) {
                            scope.translate = function (value) {
                                return value.value;
                            };
                        }
                        pointerHalfWidth = barWidth = minOffset = maxOffset = minValue = maxValue = valueRange = offsetRange = void 0;
                        dimensions = function () {
                            var value, _j, _len1, _ref2, _ref3;

                            if ((_ref2 = scope.precision) == null) {
                                scope.precision = 0;
                            }
                            if ((_ref3 = scope.step) == null) {
                                scope.step = 1;
                            }
                            for (_j = 0, _len1 = watchables.length; _j < _len1; _j++) {
                                value = watchables[_j];
                                scope[value] = roundStep(parseFloat(scope[value]), parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
                            }
                            scope.diff = roundStep(scope[refHigh] - scope[refLow], parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
                            pointerHalfWidth = halfWidth(minPtr);
                            barWidth = width(fullBar);
                            minOffset = 0;
                            maxOffset = barWidth - width(minPtr);
                            minValue = parseFloat(attributes.floor);
                            maxValue = parseFloat(attributes.ceiling);
                            valueRange = maxValue - minValue;
                            return offsetRange = maxOffset - minOffset;
                        };
                        updateDOM = function () {
                            var adjustBubbles, bindToInputEvents, fitToBar, percentOffset, percentToOffset, percentValue, setBindings, setPointers;

                            dimensions();
                            percentOffset = function (offset) {
                                return ((offset - minOffset) / offsetRange) * 100;
                            };
                            percentValue = function (value) {
                                return ((value - minValue) / valueRange) * 100;
                            };
                            percentToOffset = function (percent) {
                                return pixelize(percent * offsetRange / 100);
                            };
                            fitToBar = function (element) {
                                return offset(element, pixelize(Math.min(Math.max(0, offsetLeft(element)), barWidth - width(element))));
                            };
                            setPointers = function () {
                                var newHighValue, newLowValue;

                                offset(ceilBub, pixelize(barWidth - width(ceilBub)));
                                newLowValue = percentValue(scope[refLow]);
                                offset(minPtr, percentToOffset(newLowValue));
                                offset(lowBub, pixelize(offsetLeft(minPtr) - (halfWidth(lowBub)) + pointerHalfWidth));
                                if (range) {
                                    newHighValue = percentValue(scope[refHigh]);
                                    offset(maxPtr, percentToOffset(newHighValue));
                                    offset(highBub, pixelize(offsetLeft(maxPtr) - (halfWidth(highBub)) + pointerHalfWidth));
                                    offset(selBar, pixelize(offsetLeft(minPtr) + pointerHalfWidth));
                                    selBar.css({
                                        width: percentToOffset(newHighValue - newLowValue)
                                    });
                                    offset(selBub, pixelize(offsetLeft(selBar) + halfWidth(selBar) - halfWidth(selBub)));
                                    return offset(cmbBub, pixelize(offsetLeft(selBar) + halfWidth(selBar) - halfWidth(cmbBub)));
                                }
                            };
                            adjustBubbles = function () {
                                var bubToAdjust;

                                fitToBar(lowBub);
                                bubToAdjust = highBub;
                                if (range) {
                                    fitToBar(highBub);
                                    fitToBar(selBub);
                                    if (gap(lowBub, highBub) < 10) {
                                        hide(lowBub);
                                        hide(highBub);
                                        fitToBar(cmbBub);
                                        show(cmbBub);
                                        bubToAdjust = cmbBub;
                                    } else {
                                        show(lowBub);
                                        show(highBub);
                                        hide(cmbBub);
                                        bubToAdjust = highBub;
                                    }
                                }
                                if (gap(flrBub, lowBub) < 5) {
                                    hide(flrBub);
                                } else {
                                    if (range) {
                                        if (gap(flrBub, bubToAdjust) < 5) {
                                            hide(flrBub);
                                        } else {
                                            show(flrBub);
                                        }
                                    } else {
                                        show(flrBub);
                                    }
                                }
                                if (gap(lowBub, ceilBub) < 5) {
                                    return hide(ceilBub);
                                } else {
                                    if (range) {
                                        if (gap(bubToAdjust, ceilBub) < 5) {
                                            return hide(ceilBub);
                                        } else {
                                            return show(ceilBub);
                                        }
                                    } else {
                                        return show(ceilBub);
                                    }
                                }
                            };
                            bindToInputEvents = function (pointer, ref, events) {
                                var onEnd, onMove, onStart;

                                onEnd = function () {
                                    pointer.removeClass('active');
                                    ngDocument.unbind(events.move);
                                    return ngDocument.unbind(events.end);
                                };
                                onMove = function (event) {
                                    var eventX, newOffset, newPercent, newValue;

                                    eventX = event.clientX || event.touches[0].clientX;
                                    newOffset = eventX - element[0].getBoundingClientRect().left - pointerHalfWidth;
                                    newOffset = Math.max(Math.min(newOffset, maxOffset), minOffset);
                                    newPercent = percentOffset(newOffset);
                                    newValue = minValue + (valueRange * newPercent / 100.0);
                                    if (range) {
                                        if (ref === refLow) {
                                            if (newValue > scope[refHigh]) {
                                                ref = refHigh;
                                                minPtr.removeClass('active');
                                                maxPtr.addClass('active');
                                            }
                                        } else {
                                            if (newValue < scope[refLow]) {
                                                ref = refLow;
                                                maxPtr.removeClass('active');
                                                minPtr.addClass('active');
                                            }
                                        }
                                    }
                                    newValue = roundStep(newValue, parseInt(scope.precision), parseFloat(scope.step), parseFloat(scope.floor));
                                    scope[ref] = newValue;
                                    return scope.$apply();
                                };
                                onStart = function (event) {
                                    pointer.addClass('active');
                                    dimensions();
                                    event.stopPropagation();
                                    event.preventDefault();
                                    ngDocument.bind(events.move, onMove);
                                    return ngDocument.bind(events.end, onEnd);
                                };
                                return pointer.bind(events.start, onStart);
                            };
                            setBindings = function () {
                                var bind, inputMethod, _j, _len1, _ref2, _results;

                                boundToInputs = true;
                                bind = function (method) {
                                    bindToInputEvents(minPtr, refLow, inputEvents[method]);
                                    return bindToInputEvents(maxPtr, refHigh, inputEvents[method]);
                                };
                                _ref2 = ['touch', 'mouse'];
                                _results = [];
                                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                                    inputMethod = _ref2[_j];
                                    _results.push(bind(inputMethod));
                                }
                                return _results;
                            };

                            setPointers();
                            adjustBubbles();

                            if (!boundToInputs) {
                                return setBindings();
                            }
                        };
                        $timeout(updateDOM);
                        for (_j = 0, _len1 = watchables.length; _j < _len1; _j++) {
                            w = watchables[_j];
                            scope.$watch(w, updateDOM);
                        }
                        return window.addEventListener("resize", updateDOM);
                    }
                };
            }
        };
    };
    bufferModelDirective = function($timeout){

        return {
            restrict: 'A',
            scope: {
                bufferModel: '='
            },
            link: function(scope, elem, attr){
                var timer,
                    delay = 1000;

                var changeNow = function(){
                        if (timer != null){
                            $timeout.cancel(timer);
                        }
                        scope.bufferModel = elem.val();
                    },
                    changeOnTime = function(){
                        if (timer != null){
                            $timeout.cancel(timer);
                        }
                        timer = $timeout(function(){
                            return;
                        }, delay);
                        timer.then(changeNow);
                    };

                elem.val(scope.bufferModel);
                elem.bind('keyup', changeOnTime);
                elem.bind('blur', changeNow);
                elem.bind('keydown', function(e){
                    if (e.keyCode == 13){
                        console.log('keypress');
                        changeNow();
                    }
                });

                scope.$watch('bufferModel', function(newVal){
                    elem.val(newVal)
                })
            }
        };
    }
    logSliderDirective = function(){
        return {
            restrict: 'E',
            scope:{
                publicLow: '=ngModelLow',
                publicHigh: '=ngModelHigh',
                floorVal: '=floor',
                ceilVal: '=ceiling',
                precision: '=?',
                markers: '='
            },
            replace: true,
            template:   '<div class="log-slider">' +
                '<slider floor="0.0" ceiling="100.0" precision="9" step="0.000000001" ng-model-low="privateLow" ng-model-high="privateHigh"></slider>' +
                '</div>',
            link: function(scope, elem){
                var scale = [scope.floorVal, scope.ceilVal],
                    precision = typeof scope.precision == 'undefined' ? 0 : scope.precision,
                    getClosest = function(index){
                        var privHigh = parseFloat(scope.privateHigh),
                            privLow = parseFloat(scope.privateLow),
                            lowDiff = abs(index - privLow),
                            highDiff = abs(index - privHigh);

                        if (lowDiff === 0 && highDiff !== 0){
                            return 1;
                        } else if (highDiff === 0 && lowDiff !== 0){
                            return -1;
                        } else if (lowDiff === 0 && highDiff === 0){
                            return 0;
                        }

                        if (highDiff < lowDiff){
                            return 1;
                        } else if (lowDiff < highDiff){
                            return -1;
                        } else if (index - privLow > 0) {
                            return 1;
                        } else if (index - privLow < 0) {
                            return -1;
                        } else {
                            return -1
                        }
                    }
                    ;

                scope.privateHigh = 100;
                scope.privateLow = 0;

                scope.$watch('privateLow', function(newVal){
                    scope.publicLow = (getPointerValue(newVal, scope.markers, scale) || 0.0).toFixed(precision);
                });
                scope.$watch('privateHigh', function(newVal){
                    scope.publicHigh = (getPointerValue(newVal, scope.markers, scale) || 0.0).toFixed(precision);
                });
                scope.$watch('publicLow', function(newVal){
                    newVal = newVal.replace(/[^\d.-]/g, '');
                    scope.privateLow = getLocForPointer(parseFloat(newVal || 0), scope.markers, scale);
                });
                scope.$watch('publicHigh', function(newVal){
                    newVal = newVal.replace(/[^\d.-]/g, '');
                    scope.privateHigh = getLocForPointer(parseFloat(newVal || 0), scope.markers, scale);
                });
                elem.bind('mouseup', function(e){
                    if (e.toElement.className.indexOf('bar') === -1){
                        return;
                    }

                    var bounds = elem[0].getBoundingClientRect(),
                        percent = (e.clientX - bounds.left) / bounds.width * 100,
                        closest = getClosest(percent),
                        newPos = getPointerValue(percent, scope.markers, scale).toString();

                    scope.$apply(function(){
                        if (closest == -1){
                            scope.publicLow = newPos;
                        } else if (closest == 1){
                            scope.publicHigh = newPos;
                        }
                    });
                });
            }
        };
    }
    scaleSliderDirective = function(){
        return {
            restrict: 'E',
            scope:{
                publicLow: '=ngModelLow',
                publicHigh: '=ngModelHigh',
                scale: '='
            },
            replace: true,
            template:   '<div class="scale-slider">' +
                '<slider floor="0" ceiling="{{items.length}}" ng-model-low="privateLow" ng-model-high="privateHigh" ></slider>' +
                '<ul class="scale-items">' +
                '<li ng-repeat="item in items" class="scale-item" style="width: {{(contWidth - 1 - items.length)/items.length}}px" ng-class="{active: item.isActive}" ng-bind="item.display" ng-click="select($event, $index)"></li>' +
                '</ul>' +
                '</div>',
            link: function(scope, elem){
                if (typeof scope.scale === 'object' && scope.scale.length > 0){
                    scope.items = [];
                    if (typeof scope.scale[0] === 'string'){
                        var temp = [];
                        scope.scale.forEach(function(item){
                            temp.push({
                                value: item,
                                display: item
                            });
                        });

                        scope.items = temp;
                    } else {
                        scope.items = copy(scope.scale);
                    }
                } else {
                    scope.scale = [];
                    scope.items = [];
                }

                var defaultLow = 0,
                    width = elem.find('ul')[0].offsetWidth,
                    defaultHigh = scope.items.length ,
                    swapModels = function(){
                        var temp = scope.privateHigh;
                        scope.privateHigh = scope.privateLow;
                        scope.privateLow = temp;
                    },
                    swapPublicModels = function(){
                        var temp = scope.publicLow;
                        scope.publicLow = scope.publicHigh;
                        scope.publicHigh = temp;
                    },
                    getValue = function(i, hl){
                        if (hl === 'high'){
                            i --;
                        }

                        return scope.items[i].value;
                    },
                    getIndex = function(v, hl){
                        var index = 0;
                        scope.items.forEach(function(item, i){
                            if (item.value === v){
                                index = i;
                                return false;
                            }
                        });

                        if (hl === 'high'){
                            index += 1;
                        }

                        return index;
                    },
                    getClosest = function(index){
                        var privHigh = parseInt(scope.privateHigh) - 1,
                            privLow = parseInt(scope.privateLow),
                            low = abs(index - privLow),
                            high = abs(index - privHigh);

                        //console.log(index, privHigh, high, privLow, low);

                        if (low === 0 && high !== 0){
                            return 1;
                        } else if (high === 0 && low !== 0){
                            return -1;
                        } else if (low === 0 && high === 0){
                            return 0;
                        }

                        if (high < low){
                            return 1;
                        } else if (low < high){
                            return -1;
                        } else if (index - privLow > 0) {
                            return 1;
                        } else if (index - privLow < 0) {
                            return -1;
                        } else {
                            return -1
                        }
                    },
                    updateActive = function(){
                        scope.items.forEach(function(item, i){
                            if (i < scope.privateLow || i >= scope.privateHigh){
                                item.isActive = false;
                            } else if (i >= scope.privateLow && i < scope.privateHigh){
                                item.isActive = true;
                            }
                        });
                    },
                    setVar = function(pub, hl, value){
                        //console.log(pub, hl, value);
                        var hlUC = UCFirst(hl);
                        if (typeof value === 'undefined'){
                            if (pub === 'public'){
                                value = getValue(scope['private'+hlUC], hl);
                            } else if (pub === 'private'){
                                value = getIndex(scope['public'+hlUC], hl);
                            }
                        }
                        scope[pub+hlUC] = value;
                        if (scope.privateHigh < scope.privateLow){
                            swapModels();
                        } else if (scope.privateHigh === scope.privateLow){
                            swapPublicModels();
                        }
                        updateActive();
                    },
                    numToHL = function(i){
                        if (i > 0){
                            return 'high';
                        } else if (i < 0){
                            return 'low';
                        } else {
                            return 'low';
                        }
                    }
                    ;

                scope.privateLow = defaultLow;
                scope.privateHigh = defaultHigh;
                scope.contWidth = width;
                scope.select = function(event, index){
                    var closest = getClosest(index);
                    if (closest === 0){
                        return;
                    }

                    var hl = numToHL(closest);
                    if (hl === 'high'){
                        index ++;
                    }
                    setVar('private', hl, index);
                }

                scope.$watch('privateLow', function(newVal, oldVal){
                    if (newVal === scope.privateHigh){
                        scope.privateLow = oldVal;
                    } else {
                        setVar('public', 'low');
                    }
                });
                scope.$watch('privateHigh', function(newVal, oldVal){
                    if (newVal === scope.privateLow){
                        scope.privateHigh = oldVal;
                    } else {
                        setVar('public', 'high');
                    }
                });
                scope.$watch('publicLow', function(){
                    setVar('private', 'low');
                });
                scope.$watch('publicHigh', function(){
                    setVar('private', 'high');
                });
            }
        }
    };

    qualifiedSliderDirectiveDefinition = ['$timeout', sliderDirective];
    qualifiedBufferDirectiveDefinition = ['$timeout', bufferModelDirective];
    qualifiedLogSliderDirectiveDefinition = [logSliderDirective];
    qualifiedScaleSliderDirectiveDefinition = [scaleSliderDirective];

    module = function (window, angular) {
        return angular.module(MODULE_NAME, [])
            .directive(SLIDER_TAG, qualifiedSliderDirectiveDefinition)
            .directive(BUFFER_TAG, qualifiedBufferDirectiveDefinition)
            .directive(LOGSLIDER_TAG, qualifiedLogSliderDirectiveDefinition)
            .directive(SCALESLIDER_TAG, qualifiedScaleSliderDirectiveDefinition);
    };

    module(window, window.angular);



}).call(this);

